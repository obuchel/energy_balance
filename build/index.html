<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>Energy Balance Calculator</title><script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script><script type="text/javascript">async function loadPyodide(){try{console.log("üîÑ Loading Pyodide for enhanced food search..."),window.pyodide=await loadPyodide({indexURL:"https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"}),console.log("üì¶ Installing Python packages..."),await pyodide.loadPackage(["numpy","scikit-learn"]),console.log("üß† Setting up AI search engine..."),await pyodide.runPython("\n            import numpy as np\n            from sklearn.feature_extraction.text import TfidfVectorizer\n            from sklearn.metrics.pairwise import cosine_similarity\n            import json\n            import re\n            \n            class ClientSideSearch:\n                def __init__(self):\n                    # Advanced TF-IDF configuration for food search\n                    self.vectorizer = TfidfVectorizer(\n                        stop_words='english',\n                        ngram_range=(1, 3),  # Include trigrams for better matching\n                        max_features=5000,\n                        lowercase=True,\n                        token_pattern=r'\\\\b\\\\w+\\\\b',\n                        min_df=1,  # Include rare terms\n                        max_df=0.95  # Exclude very common terms\n                    )\n                    self.food_vectors = None\n                    self.foods = []\n                    self.search_texts = []\n                \n                def build_index(self, foods_json):\n                    \"\"\"Build the search index from food data\"\"\"\n                    try:\n                        self.foods = json.loads(foods_json)\n                        self.search_texts = []\n                        \n                        for food in self.foods:\n                            text_parts = []\n                            \n                            # Primary name (weighted heavily by duplication)\n                            name = food.get('name', '')\n                            if name:\n                                text_parts.extend([name, name, name])  # Triple weight for name\n                            \n                            # Category\n                            category = food.get('category', '')\n                            if category:\n                                text_parts.append(category)\n                            \n                            # Description\n                            description = food.get('description', '')\n                            if description:\n                                text_parts.append(description)\n                            \n                            # Add Long COVID benefits for relevant searches\n                            benefits = food.get('longCovidBenefits', [])\n                            if benefits:\n                                text_parts.extend(benefits)\n                            \n                            # Add individual words for partial matching\n                            name_words = re.findall(r'\\\\b\\\\w+\\\\b', name.lower())\n                            for word in name_words:\n                                if len(word) > 2:  # Skip very short words\n                                    text_parts.append(word)\n                                    # Add common food variations\n                                    if word.endswith('s'):\n                                        text_parts.append(word[:-1])  # Singular form\n                            \n                            # Combine all text parts\n                            search_text = ' '.join(text_parts)\n                            self.search_texts.append(search_text)\n                        \n                        # Build TF-IDF vectors\n                        if self.search_texts:\n                            self.food_vectors = self.vectorizer.fit_transform(self.search_texts)\n                            return f\"‚úÖ Search index built for {len(self.foods)} foods\"\n                        else:\n                            return \"‚ùå No valid food data provided\"\n                            \n                    except Exception as e:\n                        return f\"‚ùå Error building index: {str(e)}\"\n                \n                def search(self, query, limit=20):\n                    \"\"\"Perform intelligent multi-strategy search\"\"\"\n                    if self.food_vectors is None or not query.strip():\n                        return []\n                    \n                    try:\n                        # Clean and prepare query\n                        clean_query = query.lower().strip()\n                        \n                        # Strategy 1: TF-IDF semantic similarity search\n                        query_vector = self.vectorizer.transform([clean_query])\n                        similarities = cosine_similarity(query_vector, self.food_vectors)[0]\n                        \n                        results = []\n                        \n                        # Collect semantic matches\n                        for i, score in enumerate(similarities):\n                            if score > 0.05:  # Lower threshold for more inclusive results\n                                food = self.foods[i].copy()\n                                food['search_score'] = float(score)\n                                food['match_type'] = 'semantic'\n                                results.append(food)\n                        \n                        # Strategy 2: Exact substring matching (boost scores)\n                        for i, food in enumerate(self.foods):\n                            name_lower = food.get('name', '').lower()\n                            if clean_query in name_lower:\n                                # Check if already in results\n                                existing = next((r for r in results if r.get('id') == food.get('id')), None)\n                                if existing:\n                                    # Boost existing semantic score\n                                    existing['search_score'] += 0.6\n                                    existing['match_type'] = 'exact_substring'\n                                else:\n                                    # Add new exact match\n                                    food_copy = food.copy()\n                                    food_copy['search_score'] = 0.8\n                                    food_copy['match_type'] = 'exact_substring'\n                                    results.append(food_copy)\n                        \n                        # Strategy 3: Word prefix matching\n                        query_words = clean_query.split()\n                        for i, food in enumerate(self.foods):\n                            name_lower = food.get('name', '').lower()\n                            name_words = name_lower.split()\n                            \n                            word_matches = 0\n                            for q_word in query_words:\n                                if len(q_word) > 1:  # Skip single letters\n                                    for n_word in name_words:\n                                        if n_word.startswith(q_word):\n                                            word_matches += 1\n                                            break\n                            \n                            if word_matches > 0:\n                                match_ratio = word_matches / len(query_words)\n                                existing = next((r for r in results if r.get('id') == food.get('id')), None)\n                                if existing:\n                                    existing['search_score'] += match_ratio * 0.4\n                                else:\n                                    food_copy = food.copy()\n                                    food_copy['search_score'] = match_ratio * 0.6\n                                    food_copy['match_type'] = 'word_prefix'\n                                    results.append(food_copy)\n                        \n                        # Strategy 4: Category matching\n                        for i, food in enumerate(self.foods):\n                            category_lower = food.get('category', '').lower()\n                            if category_lower and clean_query in category_lower:\n                                existing = next((r for r in results if r.get('id') == food.get('id')), None)\n                                if existing:\n                                    existing['search_score'] += 0.3\n                                else:\n                                    food_copy = food.copy()\n                                    food_copy['search_score'] = 0.5\n                                    food_copy['match_type'] = 'category'\n                                    results.append(food_copy)\n                        \n                        # Sort by relevance score and return top results\n                        results.sort(key=lambda x: x['search_score'], reverse=True)\n                        return results[:limit]\n                        \n                    except Exception as e:\n                        print(f\"Search error: {str(e)}\")\n                        return []\n            \n            # Create global search engine instance\n            search_engine = ClientSideSearch()\n            print(\"üöÄ Python search engine initialized\")\n          "),window.pyodideReady=!0,console.log("‚úÖ Enhanced AI food search is ready!"),window.dispatchEvent(new CustomEvent("pyodideReady",{detail:{ready:!0}}))}catch(e){console.error("‚ùå Failed to load Pyodide:",e),window.pyodideReady=!1,window.dispatchEvent(new CustomEvent("pyodideError",{detail:{error:e.message}}))}}window.pyodideReady=!1,window.searchIndexBuilt=!1,document.addEventListener("DOMContentLoaded",(()=>{console.log("üéØ Starting enhanced search system..."),loadPyodide()})),window.isPyodideReady=function(){return!0===window.pyodideReady},window.getSearchStatus=function(){return window.pyodideReady&&window.searchIndexBuilt?"ready":window.pyodideReady?"indexing":window.pyodide?"loading":"unavailable"}</script><script defer="defer" src="/energy_balance/static/js/main.e90de3c8.js"></script><link href="/energy_balance/static/css/main.caeca483.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"></div><script>window.addEventListener("pyodideReady",(()=>{console.log("üéâ Enhanced food search is now available!")})),window.addEventListener("pyodideError",(e=>{console.warn("‚ö†Ô∏è Enhanced search unavailable, using basic search:",e.detail.error)}))</script></body></html>